# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: {{ ', '.join(output_file.input_filenames) }}
# plugin: python-betterproto
# This file has been @generated
{% for i in output_file.python_module_imports|sort %}
import {{ i }}
{% endfor %}

{% if output_file.pydantic_dataclasses %}
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from dataclasses import dataclass
else:
    from pydantic.dataclasses import dataclass
{%- else -%}
from dataclasses import dataclass
{% endif %}

{% if output_file.datetime_imports %}
from datetime import {% for i in output_file.datetime_imports|sort %}{{ i }}{% if not loop.last %}, {% endif %}{% endfor %}

{% endif%}
{% if output_file.typing_imports %}
from typing import {% for i in output_file.typing_imports|sort %}{{ i }}{% if not loop.last %}, {% endif %}{% endfor %}

{% endif %}

{% if output_file.pydantic_imports %}
from pydantic import {% for i in output_file.pydantic_imports|sort %}{{ i }}{% if not loop.last %}, {% endif %}{% endfor %}

{% endif %}

import betterproto
{% if output_file.services %}
import twirp
from twirp.base import Endpoint
from twirp.context import Context
from twirp.client import TwirpClient
from twirp.server import TwirpServer
from twirp.exceptions import TwirpServerException
{% endif %}

{% for i in output_file.imports|sort %}
{{ i }}
{% endfor %}

{% if output_file.imports_type_checking_only %}
from typing import TYPE_CHECKING

if TYPE_CHECKING:
{% for i in output_file.imports_type_checking_only|sort %}    {{ i }}
{% endfor %}
{% endif %}

{% if output_file.enums %}{% for enum in output_file.enums %}
class {{ enum.py_name }}(betterproto.Enum):
    {% if enum.comment %}
{{ enum.comment }}

    {% endif %}
    {% for entry in enum.entries %}
    {{ entry.name }} = {{ entry.value }}
        {% if entry.comment %}
{{ entry.comment }}

        {% endif %}
    {% endfor %}


{% endfor %}
{% endif %}
{% for message in output_file.messages %}
@dataclass(eq=False, repr=False)
class {{ message.py_name }}(betterproto.Message):
    {% if message.comment %}
{{ message.comment }}

    {% endif %}
    {% for field in message.fields %}
    {{ field.get_field_string() }}
        {% if field.comment %}
{{ field.comment }}

        {% endif %}
    {% endfor %}
    {% if not message.fields %}
    pass
    {% endif %}

    {% if message.deprecated or message.has_deprecated_fields %}
    def __post_init__(self) -> None:
        {% if message.deprecated %}
        warnings.warn("{{ message.py_name }} is deprecated", DeprecationWarning)
        {% endif %}
        super().__post_init__()
        {% for field in message.deprecated_fields %}
        if self.is_set("{{ field }}"):
            warnings.warn("{{ message.py_name }}.{{ field }} is deprecated", DeprecationWarning)
        {% endfor %}
    {%  endif %}

    {% if output_file.pydantic_dataclasses and message.has_oneof_fields %}
    @root_validator()
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)
    {%  endif %}

{% endfor %}

{% for service in output_file.services %}
class {{ service.py_name }}Client(TwirpClient):
    {% if service.comment %}
{{ service.comment }}
    {% endif %}

    {% for method in service.methods %}
    def {{ method.proto_name }}(self, *args, ctx, request, server_path_prefix="/twirp", **kwargs):
        return self._make_request(
        url=f"{server_path_prefix}/{{ output_file.package }}.{{ service.proto_name }}/{{ method.proto_name }}",
            ctx=ctx,
            request=request,
            response_obj={{ method.py_output_message_type }},
            **kwargs,
        )
    {% endfor %}
{% endfor %}

{% for service in output_file.services %}
class {{ service.py_name }}Base:
    {% for method in service.methods %}
    def {{ method.py_name }}(
        self,
        context: twirp.context.Context,
        request: "{{ method.py_input_message_type }}",
        ) -> "{{ method.py_output_message_type }}":
            raise twirp.exceptions.TwirpServerException(
                code=twirp.errors.Errors.Unimplemented,
                message=f"Not implemented"
            )

    {% endfor %}
{% endfor %}

{% for service in output_file.services %}
class {{ service.py_name }}Server(TwirpServer):
    {% if service.comment %}
{{ service.comment }}
    {% endif %}

    def __init__(self, *args, service, server_path_prefix="/twirp"):
        super().__init__(service=service)
        self._prefix = f"{server_path_prefix}/{{ output_file.package }}.{{ service.proto_name }}"
        self._endpoints = {
            {% for method in service.methods %}
            "{{ method.proto_name }}": Endpoint(
                service_name="{{ service.proto_name }}",
                name="{{ method.proto_name }}",
                function=getattr(service, "{{ method.py_name }}"),
                input={{ method.py_input_message_type }},
                output={{ method.py_output_message_type }},
            ),
            {% endfor %}
        }
{% endfor %}

{% if output_file.pydantic_dataclasses %}
{% for message in output_file.messages %}
{% if message.has_message_field %}
{{ message.py_name }}.__pydantic_model__.update_forward_refs()  # type: ignore
{% endif %}
{% endfor %}
{% endif %}
